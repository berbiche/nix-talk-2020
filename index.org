#+TITLE: Nix & Nixpkgs for a Reproducible and Declarative Build Environment
#+AUTHOR: Nicolas
#+DATE: 2020-11-15
#+EMAIL: nicolas@normie.dev

#+OPTIONS: num:nil date:nil toc:nil
#+OPTIONS: reveal_center:t reveal_progress:t reveal_history:t reveal_control:t
#+REVEAL_ROOT: https://cdn.jsdelivr.net/npm/reveal.js
#+REVEAL_INIT_OPTIONS: width: 1200, height: 800, margin: 0.1, transition: 'fade', slideNumber: true
#+REVEAL_TRANS: slide
#+REVEAL_MIN_SCALE: 0.8
#+REVEAL_MAX_SCALE: 2.5
#+REVEAL_HLEVEL: 2
#+REVEAL_THEME: black
#+REVEAL_POSTAMBLE: <p>Created by %a.</p>
#+REVEAL_PLUGINS:(markdown notes highlight)
#+REVEAL_EXTRA_CSS: style.css

#+REVEAL_TITLE_SLIDE: <h1 class="title">%t</h1>
# #+REVEAL_TITLE_SLIDE: <h2 class="author">Created by %a</h2>

* Table of Contents

- [[Context][Context]]
  + [[What Is a Package Manager's Role?][What Is a Package Manager's Role?]]
  + [[A Look at RPM][A Look at RPM]]
  + [[Issues With RPM][Issues With RPM]]
  + [[Issues With Most Package Managers][Issues With Most Package Managers]]
- [[Nix : The Package Manager][Nix : The Package Manager]]
  + [[Features][Features]]
  + [[The /nix/store][The ~/nix/store~]]
    - [[Computing a /Package/'s /store path/][Computing a /Package/'s /store path/]]
  + [[What Is a Closure][What Is a Closure]]
  + [[What Is a Derivation][What Is a Derivation]]
  + [[What Is a "nar"][What Is a "nar"]]
#+REVEAL: split
- [[Nix : The Language][Nix : The Language]]
- [[Nixpkgs : The Package Registry][Nixpkgs : The Package Registry]]
  + [[Contributing to The Project][Contributing to The Project]]
#+REVEAL: split
- [[Extras][Extras]]
  + [[NixOS][NixOS]]
  + [[home-manager][home-manager]]
- [[Further reading][Further Reading]]

* Context

** What Is a Package Manager's Role?
#+ATTR_REVEAL: :frag (frag-style appear)
- Keep track of installed packages
- Provide a way to install a package
- Provide a way to uninstall a package
- Provide a way to upgrade a package

** A Look at RPM
#+ATTR_REVEAL: :frag (frag-style appear)
- Used by Fedora and its derivatives
- Provides hooks to describe:
  #+ATTR_REVEAL: :frag (frag-style appear)
  - An installation phase
  - A build phase
  - The "uninstall phase" is implicit (all installed files are to be removed)
- A single path can be provided by a single package

#+REVEAL: split
#+ATTR_REVEAL: :code_attribs data-line-numbers='|9-11|13-14|16-19'
#+BEGIN_SRC conf
Summary: Hello World program
Name: hello
Version: 1.0
Source0: %{name}-%{version}.tar.gz

%description
This program prints out "HelloWorld".

%build
./configure --prefix=%{_prefix}
make

%install
make install

%files
/usr/bin/hello
/usr/share/man/man1/hello.1.gz
/etc/hello.conf
#+END_SRC
#+BEGIN_NOTES
This RPM spec file is not typical in that it doesn't use some of the available macros
like ~%make_install~ and ~%configure~.
#+END_NOTES

** Issues With RPM
#+ATTR_REVEAL: :frag (frag-style appear)
- Build environment inherits pre-installed dependencies
  - Having a working build across many machines is harder
  - Can be resolved by using ~Mock~ instead of ~rpmbuild~ (just a chroot)
- Not possible to do atomic upgrades of a package
  - Race conditions
    #+BEGIN_NOTES
    Service =hello-world= is running, using the =hello= binary and the =hello.conf= file. Package =hello= is upgraded and the service, at the same time, having encountered a failure, restarts, using the new binary but the old configuration file.
    #+END_NOTES
- Only a single version of a component can be installed at a given time

** Issues With Most Package Managers
#+ATTR_REVEAL: :frag (frag-style appear)
- Dependency specifications are not validated
  - Unclean build environment
- Dependency specifications are not exact, they are /nominal/ (this is explained later)
- Two dependencies cannot provide the same path (conflict between dependencies)
#+REVEAL: split
- No concept of /all-or-nothing/
  #+BEGIN_NOTES
  _all-or-nothing_: That is, either the system successfully build with all files
  correctly installed or fails and does not leave you in a partial install state.
  #+END_NOTES
- No control over external dependency management (pypi, npm, gems, etc.)
- No way to represent multiple dependencies grouped together (composition)
  #+BEGIN_NOTES
  _composition_: Some package managers have no way to represent the composition of multiple dependencies as a single unit
  #+END_NOTES

* Nix : The Package Manager
** Features
#+ATTR_REVEAL: :frag (frag-style appear)
- Rollback to previous configurations
- Atomic installation and upgrade
- High-level domain-specific language to define a /package/
- Multiple versions of a /package/ can coexist
- Deterministic build of components
  - As long as the derivation is deterministic
  - Implies reproducibility

#+REVEAL: split
- Sandboxed builds
  - No network access inside the build environment
    Unless the hash of the resulting content is known in advance (fixed output derivation)
  - The builder starts with absolutely no environment variables

#+BEGIN_NOTES
Some of the Nix-specific language used in the following slides will be explained further in this section.
#+END_NOTES

** What Is a Derivation
- Encode a specific, constant build action
- The derivation is represented in a syntax (known as /ATerm/) that can be "realized"
  to build the derivation and have the final package

** What Is a Closure
"The set of paths that might be accessed in an execution involving the component"[fn:phd-thesis]

Upon building a derivation, Nix will represent the closure using a format known as NAR.

** What Is a "nar"
The /Nix Archive Format/ (short NAR) fixes incompatibilities of ZIP and TAR with the store model.

This format is what is used to compute hashes of a derivation.

- Omit time stamps of files
- Omit ownership of files
- Support files larger than 2^32 bytes
- Preserve only the executable bit
- Guarantee an ordering of the files in the archive
#+BEGIN_NOTES
It goes that /files/ means both regular files and directories.

The exact format of a NAR is defined in Chapter 5 of Edolstra's thesis.
Edolstra's thesis is no longer exact on certain properties:
- Berkeley DB is not used anymore to retain information about the store's state,
  instead flat files are used.
#+END_NOTES

** The /nix/store
#+ATTR_REVEAL: :frag (appear)
When you install a /package/, Nix stores the package under the ~/nix/store~,
with all its dependencies (what is referred to as the closure).
#+ATTR_REVEAL: :frag (appear)
All time stamps are discarded from the files and only the executable bit is kept (Unix epoch = 0).
#+ATTR_REVEAL: :frag (appear)
The ~/nix/store~ is world-readable on a multi-user installation (the default, with a daemon).

#+REVEAL: split
Each /package/ is stored under a unique /store path/.
This /store path/ (=/nix/store/hash-derivation_name-version=) is fully deterministic and uses cryptographic hashes that is built upon a derivation's closure.
#+BEGIN_EXAMPLE
/nix/store/13xq2f3q1k64w4f8xbvnb4p0g4754wrk-emacs-ox-reveal-20201025.952
├── nix-support
│   ├── propagated-build-inputs
│   ├── propagated-user-env-packages
│   └── setup-hook
└── share
    └── emacs
        └── site-lisp
            └── elpa
                └── ox-reveal-20201025.952
                    ├── ox-reveal-autoloads.el
                    ├── ox-reveal.el
                    ├── ox-reveal.elc
                    └── ox-reveal-pkg.el
#+END_EXAMPLE

*** Why ~/nix/store~ as The Base Directory?
To allow sharing derivations across machines, the store paths have to be the same.

This will be further expanded later.

** Computing a /Package/'s /store path/
- 32 characters long base-32 (=0-9a-z= except =e,o,u,t=) encoded hash (160 entropy bits)
- Determined by the /closure/ of a package
- Current hashing function: SHA-256
#+BEGIN_NOTES
Fun fact: the characters =e,o,u,t= are excluded to prevent the creation of a hash with offensive words.
#+END_NOTES

#+REVEAL: split
- Because of the use of symbolic links within the tree, a hash
  is composed of both the store path and the symbolic name
- Source inputs and outputs have a different hash to prevent impersonation

#+BEGIN_NOTES
For more information on the cryptographic function, the chapter 5 of Edolstra's thesis goes into the finer defailts of choosing the right hashing function.

Mainly, collision resistance and second preimage resistance.

Collision resistance: making sure no two =x_1= and =x_2= -> =h(x_1) = h(x_2)=
Second preimage resistance: if =x_1= is known, is it not possible to derive =x_2= such that =h(x_1) = h(x_2)=
#+END_NOTES

** What Is a Channel
#+TODO: this section

* Nix : The Language
** Features
- *DSL* to describe a package
- Lazy
- Functional, everything is an expression
  - Currying, partial application, immutable datastructures
- Mostly pure, side-effects don't really exist
- Allows for recursive attribute sets

#+REVEAL: split
Although lazy, the language does not support lazy lists like Haskell
or other languages
#+BEGIN_SRC sh
time nix-instantiate --eval -E '
    with (import <nixpkgs> {}).lib;
    take 5 (range 0 (15000 * 1000))
'
# => 1.18s user 0.23s system 165% cpu 0.856 total
#+END_SRC

** Syntax

Adapted from [[https://learnxinyminutes.com/docs/nix][Learn X in Y Minutes, Where X=nix]]

#+REVEAL_HTML: <smaller>
#+ATTR_REVEAL: :code_attribs data-line-numbers='2-4|6-8|10-12|14-25|27-33|35-39|41-51|53-60|62-73|76-82|84-87|89-95|97-98|100-104|106-110|112-121|123-130|132-138|140-146|148-153'
#+BEGIN_SRC nix
with builtins; [
  # Inline comments look like this.
  /* Multi-line comments
     look like this. */

  (true && false)
  (true || false)
  (if 3 < 4 then "a" else "b")

  1 0 42 (-3)
  123.43 .27e13
  (4 + 6 / 2 - 2)

  "Strings literals are in double quotes."
  "
    String literals can span
    multiple lines.
  "
  ''
    a
      b
  ''
  #=> "a\n  b"
  ("ab" + "cd")   # String concatenation
  ("Your home directory is ${getEnv "HOME"}")

  (/tmp/tutorials/learn.nix == ./learn.nix == ./.+ "learn.nix")
  ./. + "learn.nix"  # => Relative folder
  /.                 # => Root Folder
  # The / operator must be surrounded by whitespace if
  # you want it to signify division.
  7/2        # This is a path literal
  (7 / 2)    # This is integer division

  (import /tmp/foo.nix)
  (import "/tmp/foo.nix")
  (import ./foo.nix)
  (import "./foo.nix")   # => Error
  (import <nixpkgs>)

  (let y = x + "b";
       x = "a";
   in y + "c")

  # Functions
  (n: n + 1)
  ((n: n + 1) 5)   #=> 6
  # Currying and partial application
  (let add = a: b: a + b
       add3 = add 3
   in add3 5)

  (length [1 2 3 "x"])
  #=> 4
  ([1 2 3] ++ [4 5])
  #=> [1 2 3 4 5]
  (concatLists [[1 2] [3 4] [5]])
  #=> [1 2 3 4 5]
  (flatten [[[1 [ 2]]] [ 3 ] 4])
  #=> [1 2 3 4]

  (head [1 2 3])
  #=> 1
  (init [1 2 3])
  #=> [1 2]
  (last [1 2 3])
  #=> 3
  (tail [1 2 3])
  #=> [2 3]
  (elemAt ["a" "b" "c" "d"] 2)
  #=> "c"
  (elem 2 [1 2 3])
  #=> true


  { foo = [1 2]; bar = "x"; }
  { a = 1; b = 2; }.a
  #=> 1
  ({ a = 1; b = 2; } ? a)
  #=> true
  ({ a = 1; b = 2; } // { a = 3; c = 4; })
  #=> { a = 3; b = 2; c = 4; }

  (let a = 1; in     { a = 2; b = a; }.b)
  #=> 1
  (let a = 1; in rec { a = 2; b = a; }.b)
  #=> 2

  # The following notation is syntactic sugar
  {
    a.b   = 1;
    a.c.d = 2;
    a.c."d.f" = 4;
  }.a.c
  #=> { d = 2; "d.f" = 4; }

  ({ a.b = { d = 2; }; }.a.b.c or 1)
  #=> 1

  {
    a = { b = 1; };
    a.b = 2;
  }
  #=> attribute 'a.b' at (string):3:5 already defined at (string):2:11

  {
    a = { b = 1; };
    a.c = 2;
  }
  #=> { a = { b = 1; c = 2; }; }

  (let a = "foo"; in {
    ${a}.b = "bar";
  }.foo)
  #=> { b = "bar"; }

  {
     "${"foo"}".a = 1;
     "${"foo"}".b = 2;
  }
  #=> error: dynamic attribute 'foo' already defined at (string):1:3

  ({x, y}: x + "-" + y) { x = "a"; y = "b"; }
  #=> "a-b"

  ({x, y}: []) { x = "a"; y = "b"; z = "c"; }
  #=> error: anonymous function called with unexpected argument ‘z’

  ({x, y, ...}: x + "-" + y) { x = "a"; y = "b"; z = "c"; }
  #=> "a-b"

  (
   (args@{x, y, ...}: removeAttrs args [ "x" "y" ])
   { x = "a"; y = "b"; z = "c"; }
  )
  #=> { z = "c"; }
  (functionArgs (args@{x, y, ...}: []))
  #=> { x= false; y = false; }

  (
    ({x, y ? "y"}: x + y)
      { x = "x"; }
  )
  #=> "xy"
  (functionArgs ({x, y ? "y"}: x + y))
  #=> { x = false; y = true; }

  (throw "foo")
  #=> error: foo
  (abort "foo")
  #=> error: evaluation aborted with the following error message: 'foo'
  (assert 1 > 2; 42)
  #=> error: assertion failed at (string):1:1
]
#+END_SRC

** Nix REPL

#+BEGIN_EXAMPLE sh
$ nix repl '<nixpkgs>'
Welcome to Nix version 3.0pre20201020_e0ca98c. Type :? for help.

Loading '<nixpkgs>'...
Added 12635 variables.

nix-repl> lib.<TAB>
lib.__unfix                          lib.mapAttrsFlatten
lib.add                              lib.mapAttrsRecursive
...

nix-repl> pkgs.hello<TAB>
pkgs.hello         pkgs.hello-unfree

nix-repl> pkgs.hello
«derivation /nix/store/j6lmvi01h17w5a1lx41xwgw00j0wbz6g-hello-2.10.drv»
#+END_EXAMPLE

** Example Package
#+ATTR_REVEAL: :code_attribs data-line-numbers="1-5|7-9|10,14|24-30|32-33|38|40-45"
#+BEGIN_SRC nix
{ stdenv, fetchurl, coreutils, pam, groff, sssd
, sendmailPath ? "/run/wrappers/bin/sendmail"
, withInsults ? false
, withSssd ? false
}:

let
  inherit (stdenv.lib) optional;
in
stdenv.mkDerivation rec {
  pname = "sudo";
  version = "1.9.3p1";

  src = fetchurl {
    url = "https://www.sudo.ws/dist/${pname}-${version}.tar.gz";
    sha256 = "17mldsg5d08s23cskmjxfa81ibnqw3slgf3l4023j72ywi9xxffw";
  };

  prePatch = ''
    # do not set sticky bit in nix store
    substituteInPlace src/Makefile.in --replace 04755 0755
  '';

  configureFlags = [
    # ...
    "--enable-tmpfiles.d=no"
  ] ++ optional withInsults [
    "--with-insults"
    "--with-all-insults"
  ];

  nativeBuildInputs = [ groff ];
  buildInputs = [ pam ];

  enableParallelBuilding = true;
  doCheck = false;

  passthru.dummy = 1;

  meta = with stdenv.lib; {
    description = "A command to run commands as root";
    license = "https://www.sudo.ws/sudo/license.html";
    maintainers = with maintainers; [ eelco delroth ];
    platforms = platforms.linux;
  };
}
#+END_SRC
#+BEGIN_NOTES
This is not the full /sudo/ expression.
#+END_NOTES

** Links
#+NAME: Links
#+CAPTION: Useful links
| builtins    | https://nixos.org/manual/nix/unstable/expressions/builtins.html |
| nixpkgs lib | https://nixos.org/manual/nixpkgs/unstable/#chap-functions       |

** A Minimal Derivation

** Build Phases

* Nixpkgs : The Package Registry
#+REVEAL: split
#+CAPTION: Amount of packages in Nixpkgs
#+NAME: fig:package-count.png
#+ATTR_ORG: :width 500
[[./images/package-count.png]][fn:package-count]
[fn:package-count]: https://discourse.nixos.org/t/how-many-people-are-paid-to-work-on-nix-nixpkgs/8307/66

** Contributing to The Project
** Build farms
** Cache

* Extras
** NixOS

** home-manager

* Further reading

| Edolstra's thesis on Nix                        | https://edolstra.github.io/pubs/phd-thesis.pdf                                              |
| Charon: Declarative Provisioning and Deployment | https://github.com/edolstra/edolstra.github.io/blob/master/pubs/charon-releng2013-final.pdf |
| home-manager options                            | https://nix-community.github.io/home-manager/options.html                                                                                            |

* Footnotes
[fn:phd-thesis] https://github.com/edolstra/edolstra.github.io/blob/master/pubs/phd-thesis.pdf
