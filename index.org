#+TITLE: Nix & Nixpkgs for a Reproducible and Declarative Build Environment
#+AUTHOR: Nicolas Berbiche
#+DATE: 2020-11-15
#+EMAIL: nicolas@normie.dev

#+OPTIONS: num:nil date:nil toc:nil
#+OPTIONS: reveal_center:t reveal_progress:t reveal_history:t reveal_control:t
#+REVEAL_ROOT: https://cdn.jsdelivr.net/npm/reveal.js
#+REVEAL_INIT_OPTIONS: width: 1200, height: 800, margin: 0.1, transition: 'fade', slideNumber: true
#+REVEAL_TRANS: slide
#+REVEAL_MIN_SCALE: 0.8
#+REVEAL_MAX_SCALE: 2.5
#+REVEAL_HLEVEL: 2
#+REVEAL_THEME: black
#+REVEAL_POSTAMBLE: <p>Create by %a.</p>
#+REVEAL_PLUGINS:(markdown notes highlight)
#+REVEAL_EXTRA_CSS: style.css

* Table of Contents

- [[Context][Context]]
  + [[What Is a Package Manager's Role?][What Is a Package Manager's Role?]]
  + [[A Look at RPM][A Look at RPM]]
  + [[Issues With RPM][Issues With RPM]]
  + [[Issues With Most Package Managers][Issues With Most Package Managers]]
- [[Nix : The Package Manager][Nix : The Package Manager]]
  + [[Features][Features]]
  + [[The /nix/store][The ~/nix/store~]]
    - [[Computing a /Package/'s /store path/][Computing a /Package/'s /store path/]]
  + [[What Is a Closure][What Is a Closure]]
  + [[What Is a Derivation][What Is a Derivation]]
  + [[What Is a "nar"][What Is a "nar"]]
#+REVEAL: split
- [[Nix : The Language][Nix : The Language]]
- [[Nixpkgs : The Package Registry][Nixpkgs : The Package Registry]]
  + [[Contributing to The Project][Contributing to The Project]]
#+REVEAL: split
- [[Extras][Extras]]
  + [[NixOS][NixOS]]
  + [[home-manager][home-manager]]
- [[Further reading][Further Reading]]

* Context

** What Is a Package Manager's Role?
#+ATTR_REVEAL: :frag (frag-style appear)
- Keep track of installed packages
- Provide a way to install a package
- Provide a way to uninstall a package
- Provide a way to upgrade a package

** A Look at RPM
#+ATTR_REVEAL: :frag (frag-style appear)
- Used by Fedora and its derivatives
- Provides hooks to describe:
  #+ATTR_REVEAL: :frag (frag-style appear)
  - An installation phase
  - A build phase
  - The "uninstall phase" is implicit (all installed files are to be removed)
- A single path can be provided by a single package

#+REVEAL: split
#+ATTR_REVEAL: :code_attribs data-line-numbers='|9-11|13-14|16-19'
#+BEGIN_SRC conf
Summary: Hello World program
Name: hello
Version: 1.0
Source0: %{name}-%{version}.tar.gz

%description
This program prints out "HelloWorld".

%build
./configure --prefix=%{_prefix}
make

%install
make install

%files
/usr/bin/hello
/usr/share/man/man1/hello.1.gz
/etc/hello.conf
#+END_SRC
#+BEGIN_NOTES
This RPM spec file is not typical in that it doesn't use some of the available macros
like ~%make_install~ and ~%configure~.
#+END_NOTES

** Issues With RPM
#+ATTR_REVEAL: :frag (frag-style appear)
- Build environment inherits pre-installed dependencies
  - Having a working build across many machines is harder
  - Can be resolved by using ~Mock~ instead of ~rpmbuild~ (just a chroot)
- Not possible to do atomic upgrades of a package
  - Race conditions
    #+BEGIN_NOTES
    Service =hello-world= is running, using the =hello= binary and the =hello.conf= file. Package =hello= is upgraded and the service, at the same time, having encountered a failure, restarts, using the new binary but the old configuration file.
    #+END_NOTES
- Only a single version of a component can be installed at a given time

** Issues With Most Package Managers
#+ATTR_REVEAL: :frag (frag-style appear)
- Dependency specifications are not validated
  - Unclean build environment
- Dependency specifications are not exact, they are /nominal/ (this is explained later)
- Two dependencies cannot provide the same path (conflict between dependencies)
#+REVEAL: split
- No concept of /all-or-nothing/
  #+BEGIN_NOTES
  _all-or-nothing_: That is, either the system successfully build with all files
  correctly installed or fails and does not leave you in a partial install state.
  #+END_NOTES
- No control over external dependency management (pypi, npm, gems, etc.)
- No way to represent multiple dependencies grouped together (composition)
  #+BEGIN_NOTES
  _composition_: Some package managers have no way to represent the composition of multiple dependencies as a single unit
  #+END_NOTES

* Nix : The Package Manager
** Features
#+ATTR_REVEAL: :frag (frag-style appear)
- Rollback to previous configurations
- Atomic installation and upgrade
- High-level domain-specific language to define a /package/
- Multiple versions of a /package/ can coexist
- Deterministic build of components
  - As long as the derivation is deterministic
  - Implies reproducibility

#+REVEAL: split
- Sandboxed builds
  - No network access inside the build environment
    Unless the hash of the resulting content is known in advance (fixed output derivation)
  - The builder starts with absolutely no environment variables

#+BEGIN_NOTES
Some of the Nix-specific language used in the following slides will be explained further in this section.
#+END_NOTES

** What Is a Derivation
- Encode a specific, constant build action
- The derivation is represented in a syntax (known as /ATerm/) that can be "realized"
  to build the derivation and have the final package

** What Is a Closure
"The set of paths that might be accessed in an execution involving the component"[fn:phd-thesis]

Upon building a derivation, Nix will represent the closure using a format known as NAR.

** What Is a "nar"
The /Nix Archive Format/ (short NAR) fixes incompatibilities of ZIP and TAR with the store model.

This format is what is used to compute hashes of a derivation.

- Omit time stamps of files
- Omit ownership of files
- Support files larger than 2^32 bytes
- Preserve only the executable bit
- Guarantee an ordering of the files in the archive
#+BEGIN_NOTES
It goes that /files/ means both regular files and directories.

The exact format of a NAR is defined in Chapter 5 of Edolstra's thesis.
Edolstra's thesis is no longer exact on certain properties:
- Berkeley DB is not used anymore to retain information about the store's state,
  instead flat files are used.
#+END_NOTES

** The /nix/store
#+ATTR_REVEAL: :frag (appear)
When you install a /package/, Nix stores the package under the ~/nix/store~,
with all its dependencies (what is referred to as the closure).
#+ATTR_REVEAL: :frag (appear)
All time stamps are discarded from the files and only the executable bit is kept (Unix epoch = 0).
#+ATTR_REVEAL: :frag (appear)
The ~/nix/store~ is world-readable on a multi-user installation (the default, with a daemon).

#+REVEAL: split
Each /package/ is stored under a unique /store path/.
This /store path/ (=/nix/store/hash-derivation_name-version=) is fully deterministic and uses cryptographic hashes that is built upon a derivation's closure.
#+BEGIN_SRC console
/nix/store/13xq2f3q1k64w4f8xbvnb4p0g4754wrk-emacs-ox-reveal-20201025.952
├── nix-support
│   ├── propagated-build-inputs
│   ├── propagated-user-env-packages
│   └── setup-hook
└── share
    └── emacs
        └── site-lisp
            └── elpa
                └── ox-reveal-20201025.952
                    ├── ox-reveal-autoloads.el
                    ├── ox-reveal.el
                    ├── ox-reveal.elc
                    └── ox-reveal-pkg.el
#+END_SRC

*** Why ~/nix/store~ as The Base Directory?
To allow sharing derivations across machines, the store paths have to be the same.

This will be further expanded later.

** Computing a /Package/'s /store path/
- 32 characters long base-32 (=0-9a-z= except =e,o,u,t=) encoded hash (160 entropy bits)
- Determined by the /closure/ of a package
- Current hashing function: SHA-256
#+BEGIN_NOTES
Fun fact: the characters =e,o,u,t= are excluded to prevent the creation of a hash with offensive words.
#+END_NOTES

#+REVEAL: split
- Because of the use of symbolic links within the tree, a hash
  is composed of both the store path and the symbolic name
- Source inputs and outputs have a different hash to prevent impersonation

#+BEGIN_NOTES
For more information on the cryptographic function, the chapter 5 of Edolstra's thesis goes into the finer defailts of choosing the right hashing function.

Mainly, collision resistance and second preimage resistance.

Collision resistance: making sure no two =x_1= and =x_2= -> =h(x_1) = h(x_2)=
Second preimage resistance: if =x_1= is known, is it not possible to derive =x_2= such that =h(x_1) = h(x_2)=
#+END_NOTES

* Nix : The Language

** Example package with syntax

#+ATTR_REVEAL: :code_attribs data-line-numbers="|1-5|7-9|10,14|24-30|32-33|38-43"
#+BEGIN_SRC nix
{ stdenv, fetchurl, coreutils, pam, groff, sssd
, sendmailPath ? "/run/wrappers/bin/sendmail"
, withInsults ? false
, withSssd ? false
}:

let
  inherit (stdenv.lib) optional;
in
stdenv.mkDerivation rec {
  pname = "sudo";
  version = "1.9.3p1";

  src = fetchurl {
    url = "https://www.sudo.ws/dist/${pname}-${version}.tar.gz";
    sha256 = "17mldsg5d08s23cskmjxfa81ibnqw3slgf3l4023j72ywi9xxffw";
  };

  prePatch = ''
    # do not set sticky bit in nix store
    substituteInPlace src/Makefile.in --replace 04755 0755
  '';

  configureFlags = [
    # ...
    "--enable-tmpfiles.d=no"
  ] ++ optional withInsults [
    "--with-insults"
    "--with-all-insults"
  ];

  nativeBuildInputs = [ groff ];
  buildInputs = [ pam ];

  enableParallelBuilding = true;
  doCheck = false;

  meta = with stdenv.lib; {
    description = "A command to run commands as root";
    license = "https://www.sudo.ws/sudo/license.html";
    maintainers = with maintainers; [ eelco delroth ];
    platforms = platforms.linux;
  };
}
#+END_SRC
#+BEGIN_NOTES
This is not the full /sudo/ expression.
#+END_NOTES

** Links

#+NAME: Links
#+CAPTION: Useful links
| builtins    | https://nixos.org/manual/nix/unstable/expressions/builtins.html |
| nixpkgs lib | https://nixos.org/manual/nixpkgs/unstable/#chap-functions       |
|             |                                                                 |

** Nix REPL

#+BEGIN_EXAMPLE sh
$ nix repl '<nixpkgs>'
Welcome to Nix version 3.0pre20201020_e0ca98c. Type :? for help.

Loading '<nixpkgs>'...
Added 12635 variables.

nix-repl> lib.<TAB>
lib.__unfix                          lib.mapAttrsFlatten
lib.add                              lib.mapAttrsRecursive
...

nix-repl> pkgs.hello<TAB>
pkgs.hello         pkgs.hello-unfree

nix-repl> pkgs.hello
«derivation /nix/store/j6lmvi01h17w5a1lx41xwgw00j0wbz6g-hello-2.10.drv»
#+END_EXAMPLE

* Nixpkgs : The Package Registry
#+REVEAL: split
#+CAPTION: Amount of packages in Nixpkgs
#+NAME: fig:package-count.png
#+ATTR_ORG: :width 500
[[./images/package-count.png]][fn:package-count]
[fn:package-count]: https://discourse.nixos.org/t/how-many-people-are-paid-to-work-on-nix-nixpkgs/8307/66

** Contributing to The Project
** Build farms
** Cache

* Extras
** NixOS

** home-manager

* Further reading

| Edolstra's thesis on Nix                        | https://edolstra.github.io/pubs/phd-thesis.pdf                                              |
| Charon: Declarative Provisioning and Deployment | https://github.com/edolstra/edolstra.github.io/blob/master/pubs/charon-releng2013-final.pdf |
| home-manager options                            | https://nix-community.github.io/home-manager/options.html                                                                                            |

* Footnotes
[fn:phd-thesis] https://github.com/edolstra/edolstra.github.io/blob/master/pubs/phd-thesis.pdf
